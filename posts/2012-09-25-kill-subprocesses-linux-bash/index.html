<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><base href=/><title>Killing Subprocesses in Linux/Bash | cnr.sh</title><link crossorigin href=https://fonts.gstatic.com rel=preconnect><link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=block" rel=stylesheet><link href=/css/style.css rel=stylesheet><link href=/css/pygments.css rel=stylesheet><link crossorigin href=https://kit.fontawesome.com/672d96e063.css rel=stylesheet><link href=/rss.xml rel=alternate type=application/rss+xml><link href=/atom.xml rel=alternate type=application/atom+xml><meta content=summary name=twitter:card><meta content="Killing Subprocesses in Linux/Bash | cnr.sh" name=twitter:title><meta content="Killing Subprocesses in Linux/Bash | cnr.sh" property=og:title><meta content=website property=og:type><meta content="Lately, I've been working with YARN at LinkedIn. This framework allows you to execute Bash scripts on one or more machines. It's used primarily for Hadoop. When using YARN, you often end up with ..." name=twitter:description><meta content="Lately, I've been working with YARN at LinkedIn. This framework allows you to execute Bash scripts on one or more machines. It's used primarily for Hadoop. When using YARN, you often end up with ..." property=og:description><meta content=/images/shoes.png name=twitter:image><meta content=/images/shoes.png property=og:image><script crossorigin integrity=sha384-HGfztofotfshcF7+8n44JQL2oJmowVChPTg48S+jvZoztPfvwD79OC/LTtG6dMp+ src=https://unpkg.com/htmx.org@2.0.4></script><script async data-uid=46504208bc src=https://cnr.kit.com/46504208bc/index.js></script></head><body hx-boost=true><header><h1><a href=/>cnr.sh</a></h1><nav><ul><li><a href=/posts>Posts</a></li><li><a href=/talks>Talks</a></li></ul></nav></header><main><h1 id=killing-subprocesses-in-linux-bash>Killing Subprocesses in Linux/Bash</h1><p>Lately, I've been working with <a href=http://hadoop.apache.org/docs/r0.23.0/hadoop-yarn/hadoop-yarn-site/YARN.html>YARN</a> at LinkedIn. This framework allows you to execute Bash scripts on one or more machines. It's used primarily for Hadoop. When using YARN, you often end up with nested Bash scripts with no parent process ID (PPID) when the NodeManager launches the Bash script. This can be pretty problematic when the NodeManager is shut down, since you must make sure to clean up all child subprocesses via your parent Bash script.</p><h2 id=killing-subprocesses-in-linux-bash_understanding-linux-subprocesses>Understanding Linux subprocesses</h2><p>Let's start with an example. We'll have two shell scripts: a parent, and a child:</p><pre><code>$ cat parent.sh 
#!/bin/bash
./child.sh
$ cat child.sh 
#!/bin/bash
sleep 1000
</code></pre><p>Normally, when you launch nested processes from a terminal, you'll see a process tree that looks something like this:</p><pre><code>UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   10911 10701  0 05:07 pts/1    00:00:00 /bin/bash ./parent.sh
ubuntu   10912 10911  0 05:07 pts/1    00:00:00 /bin/bash ./child.sh
ubuntu   10913 10912  0 05:07 pts/1    00:00:00 sleep 1000
</code></pre><p>In this example, a terminal (PID 10701) calls parent.sh, which calls child.sh, which calls sleep 1000. With YARN, you end up with a process tree that looks more like this:</p><pre><code>UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   10966     1  0 05:14 pts/1    00:00:00 /bin/bash ./parent.sh
ubuntu   10967 10966  0 05:14 pts/1    00:00:00 /bin/bash ./child.sh
ubuntu   10968 10967  0 05:14 pts/1    00:00:00 sleep 1000
</code></pre><p>Notice that the PPID of parent.sh is now 1. This is essentially a top-level process that has no parent.</p><h2 id=killing-subprocesses-in-linux-bash_unexpected-behavior>Unexpected behavior</h2><p>In both of these examples, it seems intuitive that killing the top level parent would result in all of the children being cleaned up. There are a <a href=http://en.wikipedia.org/wiki/Kill_(command>number of ways to kill a process</a>), so let's start with:</p><pre><code>$ kill -9 10966

UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   10966     1  0 05:14 pts/1    00:00:00 /bin/bash ./parent.sh
ubuntu   10967 10966  0 05:14 pts/1    00:00:00 /bin/bash ./child.sh
ubuntu   10968 10967  0 05:14 pts/1    00:00:00 sleep 1000
</code></pre><p>As expected, killing the parent does not clean up any children:</p><pre><code>UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   10967     1  0 05:14 pts/1    00:00:00 /bin/bash ./child.sh
ubuntu   10968 10967  0 05:14 pts/1    00:00:00 sleep 1000
</code></pre><p>Let's try sending a kill signal that's not quite as strong as kill -9. For a list of possible signals, try running:</p><pre><code>$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
</code></pre><p>Now, let's try this again with a normal <a href=http://en.wikipedia.org/wiki/SIGHUP>SIGHUP</a> kill. One might expect that sending such a soft kill signal should result in the child processes being cleaned up.</p><pre><code>$ kill -SIGHUP 10967

UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   10968     1  0 05:14 pts/1    00:00:00 sleep 1000
</code></pre><p>As you can see, even SIGHUP does not kill the child processes; it leaves the sleep call orphaned with a PPID of 1.</p><p>So, how can we do this properly?</p><h2 id=killing-subprocesses-in-linux-bash_traps>Traps</h2><p>One solution is to <a href=http://stackoverflow.com/questions/2525855/how-to-propagate-a-signal-through-an-arborescence-of-scripts-bash>use traps</a> in the Bash script. A trap is a way to say "do this before exiting" in a Bash script. For example, we might add the following line to parent.sh and child.sh:</p><pre><code>trap 'kill $(jobs -p)' EXIT
</code></pre><p>Now, if we kill the parent, all children will be cleaned up! Obviously, this only works with softer kill signals, such as SIGHUP. For example, if we have this process tree:</p><pre><code>UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   11049 10758  0 05:31 pts/2    00:00:00 /bin/bash ./parent.sh
ubuntu   11050 11049  0 05:31 pts/2    00:00:00 /bin/bash ./child.sh
ubuntu   11051 11050  0 05:31 pts/2    00:00:00 sleep 1000
</code></pre><p>You can execute:</p><pre><code>$ kill 11049
$ ps -ef | grep sleep
</code></pre><p>And you will see that sleep is no longer running!</p><h2 id=killing-subprocesses-in-linux-bash_top-level-trap>Top-level trap</h2><p>A variation of having a trap in each Bash file is to have a single top-level trap that uses 'ps' to find children:</p><div class=highlight><pre><span></span>kill_child_processes<span class=o>()</span><span class=w> </span><span class=o>{</span>
<span class=w>    </span><span class=nv>isTopmost</span><span class=o>=</span><span class=nv>$1</span>
<span class=w>    </span><span class=nv>curPid</span><span class=o>=</span><span class=nv>$2</span>
<span class=w>    </span><span class=nv>childPids</span><span class=o>=</span><span class=sb>`</span>ps<span class=w> </span>-o<span class=w> </span>pid<span class=w> </span>--no-headers<span class=w> </span>--ppid<span class=w> </span><span class=si>${</span><span class=nv>curPid</span><span class=si>}</span><span class=sb>`</span>
<span class=w>    </span><span class=k>for</span><span class=w> </span>childPid<span class=w> </span><span class=k>in</span><span class=w> </span><span class=nv>$childPids</span>
<span class=w>    </span><span class=k>do</span>
<span class=w>        </span>kill_child_processes<span class=w> </span><span class=m>0</span><span class=w> </span><span class=nv>$childPid</span>
<span class=w>    </span><span class=k>done</span>
<span class=w>    </span><span class=k>if</span><span class=w> </span><span class=o>[</span><span class=w> </span><span class=nv>$isTopmost</span><span class=w> </span>-eq<span class=w> </span><span class=m>0</span><span class=w> </span><span class=o>]</span><span class=p>;</span><span class=w> </span><span class=k>then</span>
<span class=w>        </span><span class=nb>kill</span><span class=w> </span>-9<span class=w> </span><span class=nv>$curPid</span><span class=w> </span><span class=m>2</span>><span class=w> </span>/dev/null
<span class=w>    </span><span class=k>fi</span>
<span class=o>}</span>

<span class=c1># Ctrl-C trap. Catches INT signal</span>
<span class=nb>trap</span><span class=w> </span><span class=s2>"kill_child_processes 1 </span><span class=nv>$$</span><span class=s2>; exit 0"</span><span class=w> </span>INT
</pre></div><p>This is a less than ideal solution, but it does work. For details, see <a href=http://stas-blogspot.blogspot.com/2010/02/kill-all-child-processes-from-shell.html>this page</a>.</p><h2 id=killing-subprocesses-in-linux-bash_kill-ppids>Kill PPIDs</h2><p>Running traps everywhere can be kind of clunky, and error prone. A cleaner approach is to use the kill command, and provide a parent process ID (PPID) instead of a process ID. To do this, the syntax gets funky. You use a negative of the parent process ID, like so:</p><pre><code>$ kill -- -&LTPPID>
</code></pre><p>For example, with this process tree:</p><pre><code>UID        PID  PPID  C STIME  TTY         TIME CMD
ubuntu   11096     1  0 05:36 ?        00:00:00 /bin/bash ./parent.sh
ubuntu   11097 11096  0 05:36 ?        00:00:00 /bin/bash ./child.sh
ubuntu   11098 11097  0 05:36 ?        00:00:00 sleep 1000
</code></pre><p>You would run:</p><pre><code>$ kill -- -11096
$ ps -ef | grep sleep
</code></pre><p>As you can see, killing with a PPID automatically cleans all subprocesses, including nested subprocesses!</p><h2 id=killing-subprocesses-in-linux-bash_exec>exec</h2><p>Another handy trick is to use <a href=http://linux.die.net/man/3/exec>exec</a> when nesting Bash calls. Exec replaces the "current" process with the "child" process. This doesn't always work, but for our example (parent, child, sleep), it certainly does. Let's make parent and child look like this, respectively:</p><pre><code>$ cat parent.sh
#!/bin/bash
exec ./child.sh
$ cat child.sh
#!/bin/bash
exec sleep 1000
</code></pre><p>Notice the "exec" command preceding the child.sh and sleep calls. Let's have a look at the process tree:</p><pre><code>$ ps -ef | grep parent
$ ps -ef | grep child
$ ps -ef | grep sleep
ubuntu   11155 10758  0 05:41 pts/2    00:00:00 sleep 1000
</code></pre><p>As you can see, only a 'sleep' process exists. The parent.sh script "becomes" child.sh, and child.sh "becomes" sleep. This makes it very easy to clean up child processes, because there are none! To clean up, you simply kill the 'sleep' process. This is the method that I use with YARN, since I'm executing nested Bash calls that lead to a single Java process.</p><h2 id=killing-subprocesses-in-linux-bash_python>Python</h2><p>If you're not strictly tied to Bash, you might be interested in Python's <a href=http://code.google.com/p/psutil/>psutil</a> library. It <a href=http://stackoverflow.com/questions/1230669/subprocess-deleting-child-processes-in-windows>can be used to kill all subprocess</a> for a given process ID.</p><h2 id=killing-subprocesses-in-linux-bash_setsid>setsid</h2><p>One other minor note. You might be wondering how you end up with a PPID of 1. Obviously, kill -9'ing will do it. You can also use a command called <a href=http://linux.die.net/man/2/setsid>setsid</a>. This is what YARN does when its NodeManager executes a child process. To try and execute parent.sh with a PPID of 1, execute:</p><pre><code>setsid ./parent.sh
</code></pre><p>For further reading, check the <a href=http://en.wikipedia.org/wiki/Nohup>nohup</a> wiki, which can be used as an alternative to setsid.</p><hr><h4>Changelog</h4><ul><li><strong>Fix redirects</strong> on February 11, 2025</li><li><strong>Migrate to markupdown (#1)</strong> on February 11, 2025</li></ul><hr><script async data-uid=9277dcb391 src=https://cnr.kit.com/9277dcb391/index.js></script></main><script defer src=https://tinylytics.app/embed/DsgFkjZH7dLkhSPiTKbn.js></script></body></html>